import fs from 'fs';
import path from 'path';
import mkdirp from 'mkdirp';
import { inputToConfig, loadConfig } from './config';
import { ImportsFsEngine, resolvers } from '@resolver-engine/imports-fs';
import { gatherSources } from '@resolver-engine/imports';
import { findInputs } from './findInputs';
import { getExtensionForCompilerType } from './utils';
export async function flattenProject(configPath) {
    await flattenAndSave(await loadConfig(configPath));
}
export async function flattenAndSave(input) {
    const config = inputToConfig(input);
    const output = await getContractDependency(config);
    await saveToFile(output, config);
}
async function getContractDependency(config) {
    const resolver = ImportsFsEngine().addResolver(resolvers.BacktrackFsResolver(config.nodeModulesDirectory));
    const allContracts = findInputs(config.sourceDirectory, getExtensionForCompilerType(config));
    return Promise.all(allContracts.map(async (contract) => gatherSources([contract], '.', resolver)));
}
const fsOps = {
    createDirectory: mkdirp.sync,
    writeFile: fs.writeFileSync
};
function saveToFile(output, config, fileSystem = fsOps) {
    const outputDirectory = config.flattenOutputDirectory;
    fileSystem.createDirectory(outputDirectory);
    output.map((contract) => {
        const fileName = path.parse(contract[0].url).base;
        const filePath = path.join(outputDirectory, fileName);
        let source = '';
        contract.map(dependency => {
            source = replaceDirectivesWithComments(dependency, contract, source);
        });
        fileSystem.writeFile(filePath, source);
    });
}
function replaceDirectivesWithComments(dependency, contract, source) {
    const IMPORT_SOLIDITY_REGEX = /import/gi;
    const PRAGMA_SOLIDITY_REGEX = /pragma/gi;
    const sourceWithCommentedImports = dependency.source.replace(IMPORT_SOLIDITY_REGEX, '// import');
    if (dependency === contract[0]) {
        return sourceWithCommentedImports;
    }
    else {
        const sourceWithCommentedPragmas = sourceWithCommentedImports.replace(PRAGMA_SOLIDITY_REGEX, '// pragma');
        return `// Dependency file: ${dependency.url}\n\n` + sourceWithCommentedPragmas + '\n' + source;
    }
}
