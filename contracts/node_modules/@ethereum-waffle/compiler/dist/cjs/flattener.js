"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const config_1 = require("./config");
const imports_fs_1 = require("@resolver-engine/imports-fs");
const imports_1 = require("@resolver-engine/imports");
const findInputs_1 = require("./findInputs");
const utils_1 = require("./utils");
async function flattenProject(configPath) {
    await flattenAndSave(await config_1.loadConfig(configPath));
}
exports.flattenProject = flattenProject;
async function flattenAndSave(input) {
    const config = config_1.inputToConfig(input);
    const output = await getContractDependency(config);
    await saveToFile(output, config);
}
exports.flattenAndSave = flattenAndSave;
async function getContractDependency(config) {
    const resolver = imports_fs_1.ImportsFsEngine().addResolver(imports_fs_1.resolvers.BacktrackFsResolver(config.nodeModulesDirectory));
    const allContracts = findInputs_1.findInputs(config.sourceDirectory, utils_1.getExtensionForCompilerType(config));
    return Promise.all(allContracts.map(async (contract) => imports_1.gatherSources([contract], '.', resolver)));
}
const fsOps = {
    createDirectory: mkdirp_1.default.sync,
    writeFile: fs_1.default.writeFileSync
};
function saveToFile(output, config, fileSystem = fsOps) {
    const outputDirectory = config.flattenOutputDirectory;
    fileSystem.createDirectory(outputDirectory);
    output.map((contract) => {
        const fileName = path_1.default.parse(contract[0].url).base;
        const filePath = path_1.default.join(outputDirectory, fileName);
        let source = '';
        contract.map(dependency => {
            source = replaceDirectivesWithComments(dependency, contract, source);
        });
        fileSystem.writeFile(filePath, source);
    });
}
function replaceDirectivesWithComments(dependency, contract, source) {
    const IMPORT_SOLIDITY_REGEX = /import/gi;
    const PRAGMA_SOLIDITY_REGEX = /pragma/gi;
    const sourceWithCommentedImports = dependency.source.replace(IMPORT_SOLIDITY_REGEX, '// import');
    if (dependency === contract[0]) {
        return sourceWithCommentedImports;
    }
    else {
        const sourceWithCommentedPragmas = sourceWithCommentedImports.replace(PRAGMA_SOLIDITY_REGEX, '// pragma');
        return `// Dependency file: ${dependency.url}\n\n` + sourceWithCommentedPragmas + '\n' + source;
    }
}
