"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const Doppelganger_json_1 = __importDefault(require("./Doppelganger.json"));
async function deploy(wallet) {
    const factory = new ethers_1.ContractFactory(Doppelganger_json_1.default.abi, Doppelganger_json_1.default.bytecode, wallet);
    return factory.deploy();
}
function stub(mockContract, encoder, func, params) {
    const callData = params ? func.encode(params) : func.sighash;
    return {
        returns: async (...args) => {
            const encoded = encoder.encode(func.outputs, args);
            await mockContract.__waffle__mockReturns(callData, encoded);
        },
        reverts: async () => mockContract.__waffle__mockReverts(callData),
        withArgs: (...args) => stub(mockContract, encoder, func, args)
    };
}
function createMock(abi, mockContractInstance) {
    const { functions } = new ethers_1.utils.Interface(abi);
    const encoder = new ethers_1.utils.AbiCoder();
    return Object.values(functions).reduce((acc, func) => ({
        ...acc,
        [func.name]: stub(mockContractInstance, encoder, func)
    }), {});
}
async function deployMockContract(wallet, abi) {
    console.warn('deployMockContract is an experimental feature. ' +
        'Breaking changes will not result in a new major version');
    const mockContractInstance = await deploy(wallet);
    const mock = createMock(abi, mockContractInstance);
    const mockedContract = new ethers_1.Contract(mockContractInstance.address, abi, wallet);
    mockedContract.mock = mock;
    return mockedContract;
}
exports.deployMockContract = deployMockContract;
